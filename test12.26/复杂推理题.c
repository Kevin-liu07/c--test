/*
1.这道题的答案是

A.A  B.B C.C D.D

2.第5题的答案是

A.C B.D C.A D.B

3.以下选项中哪一题的答案与其他三项不同

A.第3题 B.第6题 C.第2题 D.第4题

4.以下选项中哪两题的答案相同

A.第1，5题 B.第2，7题 C.第1，9题 D.第6，10题

5.以下选项中哪一题的答案与本题相同

A.第8题 B.第4题 C.第9题 D.第7题

6.以下选项中哪两题的答案与第8题相同

A.第2，4题 B.第1，6题 C.第3，10题 D.第5，9题

7.在此十道题中，被选择次数最少的选项字母为

A.C B.B C.A D.D

8.以下选项中哪一题的答案与第1题的答案在字母表中不相邻

A.第7题 B.第5题 C.第2题 D.第10题

9.已知“第1题与第6题的答案相同”与“第X题与第5题的答案相同”的真假性相反，那么X为

A.第6题 B.第10题 C.第2题 D.第9题

10.在此十道题中，ABCD四个字母中出现的次数最多者与最少者的差为

A.3 B.2 C.4 D.1
*/

int MinTimes(int a[], int n)
{
	int i, abcd[4] = { 0 };
	for (i = 0; i<n; i++) abcd[a[1 + i]]++;

	int min = abcd[0], j = 0;
	for (i = 0; i<4; i++)
	{
		if (min>abcd[i]) { min = abcd[i]; j = i; }
	}
	return j;
}

int main(int argc, char* argv[])
{
	int i;
	int a[11];
	for (a[1] = 0; a[1]<4; a[1]++)
		for (a[2] = 0; a[2]<4; a[2]++)
			for (a[3] = 0; a[3]<4; a[3]++)
				for (a[4] = 0; a[4]<4; a[4]++)
					for (a[5] = 0; a[5]<4; a[5]++)
						for (a[6] = 0; a[6]<4; a[6]++)
							for (a[7] = 0; a[7]<4; a[7]++)
								for (a[8] = 0; a[8]<4; a[8]++)
									for (a[9] = 0; a[9]<4; a[9]++)
										for (a[10] = 0; a[10]<4; a[10]++)
										{	//用continue 语句，构成了一关关开始闯关的逻辑，思路清晰，代码结构简洁、易懂、利于维护
		//	2.第5题的答案是 A.C B.D C.A D.B 
		if (a[2] == 0 && a[5] == 2) 			{ ; }  //空分支体也是 逻辑或的形式。
		else if (a[2] == 1 && a[5] == 3) 	{ ; }
		else if (a[2] == 2 && a[5] == 0)		{ ; }
		else if (a[2] == 3 && a[5] == 1) 	{ ; }
		else    continue;  //下一个候选者

		//3.以下选项中哪一题的答案与其他三项不同 A.第3题 B.第6题 C.第2题 D.第4题
		if (a[3] == 0 && a[3] != a[6] && a[6] == a[2] && a[2] == a[4]) { ; }
		else  if (a[3] == 1 && a[6] != a[3] && a[3] == a[2] && a[2] == a[4]) { ; }
		else if (a[3] == 2 && a[2] != a[6] && a[6] == a[3] && a[3] == a[4]) { ; }
		else if (a[3] == 3 && a[4] != a[6] && a[6] == a[2] && a[2] == a[3]) { ; }
		else 	continue;

		//4.以下选项中哪两题的答案相同 A.第1，5题 B.第2，7题 C.第1，9题 D.第6，10题
		if (a[4] == 0 && a[1] == a[5]) { ; }
		else if (a[4] == 1 && a[2] == a[7]) { ; }
		else if (a[4] == 2 && a[1] == a[9]) { ; }
		else if (a[4] == 3 && a[6] == a[10]) { ; }
		else continue;

		//5.以下选项中哪一题的答案与本题相同 A.第8题 B.第4题 C.第9题 D.第7题

		if (a[5] == 0 && a[8] == a[5]) { ; }
		else if (a[5] == 1 && a[4] == a[5]) { ; }
		else if (a[5] == 2 && a[9] == a[5]) { ; }
		else if (a[5] == 3 && a[7] == a[5]) { ; }
		else continue;

		//6.以下选项中哪两题的答案与第8题相同A.第2，4题 B.第1，6题 C.第3，10题 D.第5，9题
		if (a[6] == 0 && a[8] == a[2] && a[8] == a[4]) { ; }
		else if (a[6] == 1 && a[8] == a[1] && a[8] == a[6]) { ; }
		else if (a[6] == 2 && a[8] == a[3] && a[8] == a[10]) { ; }
		else if (a[6] == 3 && a[8] == a[5] && a[8] == a[9]) { ; }
		else continue;

		//8.以下选项中哪一题的答案与第1题的答案在字母表中不相邻 A.第7题 B.第5题 C.第2题 D.第10题
		if (a[8] == 0 && (abs(a[7] - a[1]) != 1) && (abs(a[5] - a[1]) == 1) && (abs(a[2] - a[1]) == 1) && (abs(a[10] - a[1]) == 1)) { ; }
		else if (a[8] == 1 && (abs(a[5] - a[1]) != 1) && (abs(a[7] - a[1]) == 1) && (abs(a[2] - a[1]) == 1) && (abs(a[10] - a[1]) == 1)) { ; }
		else if (a[8] == 2 && (abs(a[2] - a[1]) != 1) && (abs(a[7] - a[1]) == 1) && (abs(a[5] - a[1]) == 1) && (abs(a[10] - a[1]) == 1)) { ; }
		else if (a[8] == 3 && (abs(a[10] - a[1]) != 1) && (abs(a[7] - a[1]) == 1) && (abs(a[5] - a[1]) == 1) && (abs(a[2] - a[1]) == 1)) { ; }
		else continue;

		//9.已知“第1题与第6题的答案相同”与“第X题与第5题的答案相同”的真假性相反，那么X为A.第6题 B.第10题 C.第2题 D.第9题
		//用到XOR运算符号，作推理, 代码简洁
		if (a[9] == 0 && ((a[1] == a[6]) ^ (a[6] == a[5]))) { ; }
		else if (a[9] == 1 && ((a[1] == a[6]) ^ (a[10] == a[5]))) { ; }
		else if (a[9] == 2 && ((a[1] == a[6]) ^ (a[2] == a[5]))) { ; }
		else if (a[9] == 3 && ((a[1] == a[6]) ^ (a[9] == a[5]))) { ; }
		else continue;
		//7. 
		if (a[7] == 0 && MinTimes(a, 10) == 2){ ; }
		else if (a[7] == 1 && MinTimes(a, 10) == 1){ ; }
		else if (a[7] == 2 && MinTimes(a, 10) == 0){ ; }
		else if (a[7] == 3 && MinTimes(a, 10) == 3){ ; }
		else continue;

		//10关不用了


		printf("\n过关的候选者");

		for (i = 1; i <= 10; i++) printf(" %c", a[i] + 'a');
										}




	return 0;
}